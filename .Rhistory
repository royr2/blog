)
# First attach model output to test dataset
test$pred <- predict(mdl, newdata = test)
unique(train$home_ownership)
unique(test$home_ownership)
knitr::opts_chunk$set(collapse = TRUE)
library(pacman)
# p_load automatically installs packages if needed
p_load(dplyr, magrittr, knitr)
sample <- read.csv("/Github/royr2/download/credit_sample.csv")
dim(sample)
class(sample)
unique(sample$loan_status)
# For simplicity we'll just use
# 1. "Charged Off"
# 2. "Does not meet the credit policy. Status:Charged Off"
codes <- c("Charged Off", "Does not meet the credit policy. Status:Charged Off")
sample %<>% mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))
sample %>%
summarise(events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0)) %>%
mutate(event_rate = events/(events + non_events))
# Replace all NA values with a default value
sample[is.na(sample)] <- -1
sample %<>%
# Remove cases where home ownership and payment plan are not reported
filter(! home_ownership %in% c("", "NONE"),
pymnt_plan != "") %>%
# Convert these two variables into factors
mutate(home_ownership = factor(home_ownership),
pymnt_plan = factor(pymnt_plan))
# Train Test split
idx <- sample(1:nrow(sample), size = 0.7 * nrow(sample), replace = F)
train <- sample[idx,]
test <- sample[-idx,]
dim(train)
dim(test)
mdl <- glm(
formula = bad_flag ~
loan_amnt + term + mths_since_last_delinq +
home_ownership + pymnt_plan,
family = "binomial",
data = train
)
# First attach model output to test dataset
test$pred <- predict(mdl, newdata = test)
hist(test$pred)
# Bin predictions based on quantiles
q <- quantile(test$pred, probs = seq(0, 1, length.out = 10))
test$bins <- cut(test$pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
knitr::opts_chunk$set(collapse = TRUE)
library(pacman)
# p_load automatically installs packages if needed
p_load(dplyr, magrittr, knitr)
sample <- read.csv("/Github/royr2/download/credit_sample.csv")
dim(sample)
class(sample)
unique(sample$loan_status)
# For simplicity we'll just use
# 1. "Charged Off"
# 2. "Does not meet the credit policy. Status:Charged Off"
codes <- c("Charged Off", "Does not meet the credit policy. Status:Charged Off")
sample %<>% mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))
sample %>%
summarise(events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0)) %>%
mutate(event_rate = events/(events + non_events))
# Replace all NA values with a default value
sample[is.na(sample)] <- -1
sample %<>%
# Remove cases where home ownership and payment plan are not reported
filter(! home_ownership %in% c("", "NONE"),
pymnt_plan != "") %>%
# Convert these two variables into factors
mutate(home_ownership = factor(home_ownership),
pymnt_plan = factor(pymnt_plan))
# Train Test split
idx <- sample(1:nrow(sample), size = 0.7 * nrow(sample), replace = F)
train <- sample[idx,]
test <- sample[-idx,]
dim(train)
dim(test)
# Using a GLM model for simplicity
mdl <- glm(
formula = bad_flag ~
loan_amnt + term + mths_since_last_delinq +
home_ownership + pymnt_plan,
family = "binomial",
data = train
)
test$pred <- predict(mdl, newdata = test)
# Bin predictions based on quantiles
q <- quantile(test$pred, probs = seq(0, 1, length.out = 10))
test$bins <- cut(test$pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
levels(test$bins)
# Start with the test dataset and start to summarise
gains_table <- test %>%
group_by(bins) %>%
summarise(total = n(),
events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0))
kable(gains_table)
gains_table %<>%
mutate(event_rate = round(events / total, 3),
non_event_rate = round(non_events/total, 3))
kable(gains_table)
gains_table %<>%
mutate(pop_pct = total/sum(total),
c.events = cumsum(events) / sum(events),
c.non_events = cumsum(non_events) / sum(non_events))
kable(gains_table)
# p_load automatically installs packages if needed
p_load(dplyr, magrittr, knitr, scales)
names(sample)
knitr::opts_chunk$set(collapse = TRUE)
library(pacman)
# p_load automatically installs packages if needed
p_load(dplyr, magrittr, knitr, scales)
sample <- read.csv("/Github/royr2/download/credit_sample.csv")
dim(sample)
class(sample)
unique(sample$loan_status)
# For simplicity we'll just use
# 1. "Charged Off"
# 2. "Does not meet the credit policy. Status:Charged Off"
codes <- c("Charged Off", "Does not meet the credit policy. Status:Charged Off")
# For details on the %<>% operator please look at the dcumentation for the magrittr
# package.
sample %<>% mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))
sample %>%
summarise(events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0)) %>%
mutate(event_rate = events/(events + non_events))
# Replace all NA values with a default value
sample[is.na(sample)] <- -1
sample %<>%
# Remove cases where home ownership and payment plan are not reported
filter(! home_ownership %in% c("", "NONE"),
pymnt_plan != "") %>%
# Convert these two variables into factors
mutate(home_ownership = factor(home_ownership),
pymnt_plan = factor(pymnt_plan))
# Train Test split
idx <- sample(1:nrow(sample), size = 0.7 * nrow(sample), replace = F)
train <- sample[idx,]
test <- sample[-idx,]
dim(train)
dim(test)
# Using a GLM model for simplicity
mdl <- glm(
formula = bad_flag ~
loan_amnt + term + mths_since_last_delinq +
home_ownership + pymnt_plan +
inq_last_6mths + delinq_amnt +
mths_since_last_record + mths_since_recent_revol_delinq +
mths_since_last_major_derog,
family = "binomial",
data = train
)
test$pred <- predict(mdl, newdata = test)
# Bin predictions based on quantiles
q <- quantile(test$pred, probs = seq(0, 1, length.out = 10))
test$bins <- cut(test$pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
levels(test$bins)
# Start with the test dataset and start to summarise
gains_table <- test %>%
group_by(bins) %>%
summarise(total = n(),
events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0))
kable(gains_table)
gains_table %<>%
mutate(event_rate = percent(events / total, 0.1, 100),
non_event_rate = percent(non_events/total, 0.1, 100))
kable(gains_table)
gains_table %<>%
mutate(pop_pct = percent(total/sum(total), 0.1, 100),
c.events = percent(cumsum(events) / sum(events), 0.1, 100),
c.non_events = percent(cumsum(non_events) / sum(non_events), 0.1, 100))
kable(gains_table)
gains_table %<>%
mutate(cap_rate = percent(cumsum(events)/sum(events), 0.0, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.01, 100))
kable(gains_table)
gains_table %<>%
mutate(cap_rate = percent(cumsum(events)/sum(events), 0.1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100))
gains_table %<>%
mutate(cap_rate = percent(cumsum(events)/sum(events), 0.1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100))
kable(gains_table)
gains_table %<>%
mutate(cap_rate = percent(cumsum(events)/sum(events), 0, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100))
kable(gains_table)
gains_table %<>%
mutate(cap_rate = percent(cumsum(events)/sum(events), 1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100))
kable(gains_table)
names(sample)
blogdown::stop_server()
blogdown::serve_site()
knitr::opts_chunk$set(collapse = TRUE)
library(pacman)
# p_load automatically installs packages if needed
p_load(dplyr, magrittr, knitr, scales)
sample <- read.csv("/Github/royr2/download/credit_sample.csv")
dim(sample)
class(sample)
unique(sample$loan_status)
# For simplicity we'll just use
# 1. "Charged Off"
# 2. "Does not meet the credit policy. Status:Charged Off"
codes <- c("Charged Off", "Does not meet the credit policy. Status:Charged Off")
# For details on the %<>% operator please look at the dcumentation for the magrittr
# package.
sample %<>% mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))
sample %>%
summarise(events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0)) %>%
mutate(event_rate = events/(events + non_events))
# Replace all NA values with a default value
sample[is.na(sample)] <- -1
sample %<>%
# Remove cases where home ownership and payment plan are not reported
filter(! home_ownership %in% c("", "NONE"),
pymnt_plan != "") %>%
# Convert these two variables into factors
mutate(home_ownership = factor(home_ownership),
pymnt_plan = factor(pymnt_plan))
# Train Test split
idx <- sample(1:nrow(sample), size = 0.7 * nrow(sample), replace = F)
train <- sample[idx,]
test <- sample[-idx,]
dim(train)
dim(test)
# Using a GLM model for simplicity
mdl <- glm(
formula = bad_flag ~
loan_amnt + term + mths_since_last_delinq +
home_ownership + pymnt_plan + dti + dti_joint +
inq_last_6mths + delinq_amnt +
mths_since_last_record + mths_since_recent_revol_delinq +
mths_since_last_major_derog + mths_since_recent_inq +
mths_since_recent_bc + num_accts_ever_120_pd,
family = "binomial",
data = train
)
test$pred <- predict(mdl, newdata = test)
# Bin predictions based on quantiles
q <- quantile(test$pred, probs = seq(0, 1, length.out = 11))
test$bins <- cut(test$pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
levels(test$bins)
# Start with the test dataset and start to summarise
gains_table <- test %>%
group_by(bins) %>%
summarise(total = n(),
events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0))
kable(gains_table)
gains_table %<>%
mutate(event_rate = percent(events / total, 0.1, 100))
kable(gains_table)
gains_table %<>%
mutate(pop_pct = percent(total/sum(total), 0.1, 100),
# Not formatting these as percents just yet
c.events_pct = cumsum(events) / sum(events),
c.non_events_pct = cumsum(non_events) / sum(non_events))
kable(gains_table)
gains_table %<>%
mutate(ks = round(abs(c.events_pct - c.non_events_pct), 2),
cap_rate = percent(cumsum(events)/sum(events), 1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100),
#Finally format the remaining columns
c.events_pct = percent(c.events_pct, 0.1, 100),
c.non_events_pct = percent(c.non_events_pct, 0.1, 100))
kable(gains_table)
blogdown::build_site()
blogdown::stop_server()
names(sample)
knitr::opts_chunk$set(collapse = TRUE)
library(pacman)
# p_load automatically installs packages if needed
p_load(dplyr, magrittr, knitr, scales)
sample <- read.csv("/Github/royr2/download/credit_sample.csv")
dim(sample)
class(sample)
unique(sample$loan_status)
# For simplicity we'll just use
# 1. "Charged Off"
# 2. "Does not meet the credit policy. Status:Charged Off"
codes <- c("Charged Off", "Does not meet the credit policy. Status:Charged Off")
# For details on the %<>% operator please look at the dcumentation for the magrittr
# package.
sample %<>% mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))
sample %>%
summarise(events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0)) %>%
mutate(event_rate = events/(events + non_events))
# Replace all NA values with a default value
sample[is.na(sample)] <- -1
sample %<>%
# Remove cases where home ownership and payment plan are not reported
filter(! home_ownership %in% c("", "NONE"),
pymnt_plan != "") %>%
# Convert these two variables into factors
mutate(home_ownership = factor(home_ownership),
pymnt_plan = factor(pymnt_plan))
# Train Test split
idx <- sample(1:nrow(sample), size = 0.7 * nrow(sample), replace = F)
train <- sample[idx,]
test <- sample[-idx,]
dim(train)
dim(test)
# Using a GLM model for simplicity
mdl <- glm(
formula = bad_flag ~
loan_amnt + term + mths_since_last_delinq + total_pymnt +
home_ownership + acc_now_delinq +
inq_last_6mths + delinq_amnt +
mths_since_last_record + mths_since_recent_revol_delinq +
mths_since_last_major_derog + mths_since_recent_inq +
mths_since_recent_bc + num_accts_ever_120_pd,
family = "binomial",
data = train
)
test$pred <- predict(mdl, newdata = test)
# Bin predictions based on quantiles
q <- quantile(test$pred, probs = seq(0, 1, length.out = 11))
test$bins <- cut(test$pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
levels(test$bins)
# Start with the test dataset and start to summarise
gains_table <- test %>%
group_by(bins) %>%
summarise(total = n(),
events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0))
kable(gains_table)
gains_table %<>%
mutate(event_rate = percent(events / total, 0.1, 100))
kable(gains_table)
gains_table %<>%
mutate(pop_pct = percent(total/sum(total), 0.1, 100),
# Not formatting these as percents just yet
c.events_pct = cumsum(events) / sum(events),
c.non_events_pct = cumsum(non_events) / sum(non_events))
kable(gains_table)
gains_table %<>%
mutate(ks = round(abs(c.events_pct - c.non_events_pct), 2),
cap_rate = percent(cumsum(events)/sum(events), 1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100),
#Finally format the remaining columns
c.events_pct = percent(c.events_pct, 0.1, 100),
c.non_events_pct = percent(c.non_events_pct, 0.1, 100))
kable(gains_table)
blogdown::serve_site()
library(DT)
datatable(mtcars)
knitr::opts_chunk$set(collapse = TRUE)
library(pacman)
# p_load automatically installs packages if needed
p_load(dplyr, magrittr, knitr, scales)
sample <- read.csv("/Github/royr2/download/credit_sample.csv")
dim(sample)
class(sample)
unique(sample$loan_status)
# For simplicity we'll just use
# 1. "Charged Off"
# 2. "Does not meet the credit policy. Status:Charged Off"
codes <- c("Charged Off", "Does not meet the credit policy. Status:Charged Off")
# For details on the %<>% operator please look at the dcumentation for the magrittr
# package.
sample %<>% mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))
sample %>%
summarise(events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0)) %>%
mutate(event_rate = events/(events + non_events))
# Replace all NA values with a default value
sample[is.na(sample)] <- -1
sample %<>%
# Remove cases where home ownership and payment plan are not reported
filter(! home_ownership %in% c("", "NONE"),
pymnt_plan != "") %>%
# Convert these two variables into factors
mutate(home_ownership = factor(home_ownership),
pymnt_plan = factor(pymnt_plan))
# Train Test split
idx <- sample(1:nrow(sample), size = 0.7 * nrow(sample), replace = F)
train <- sample[idx,]
test <- sample[-idx,]
dim(train)
dim(test)
# Using a GLM model for simplicity
mdl <- glm(
formula = bad_flag ~
loan_amnt + term + mths_since_last_delinq + total_pymnt +
home_ownership + acc_now_delinq +
inq_last_6mths + delinq_amnt +
mths_since_last_record + mths_since_recent_revol_delinq +
mths_since_last_major_derog + mths_since_recent_inq +
mths_since_recent_bc + num_accts_ever_120_pd,
family = "binomial",
data = train
)
test$pred <- predict(mdl, newdata = test)
# Bin predictions based on quantiles
q <- quantile(test$pred, probs = seq(0, 1, length.out = 11))
test$bins <- cut(test$pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
levels(test$bins)
# Start with the test dataset and start to summarise
gains_table <- test %>%
group_by(bins) %>%
summarise(total = n(),
events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0))
kable(gains_table)
gains_table %<>%
mutate(event_rate = percent(events / total, 0.1, 100))
kable(gains_table)
gains_table %<>%
mutate(pop_pct = percent(total/sum(total), 0.1, 100),
# Not formatting these as percentages just yet
c.events_pct = cumsum(events) / sum(events),
c.non_events_pct = cumsum(non_events) / sum(non_events))
kable(gains_table)
gains_table %<>%
mutate(ks = round(abs(c.events_pct - c.non_events_pct), 2),
cap_rate = percent(cumsum(events)/sum(events), 1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100),
# Format pending columns
c.events_pct = percent(c.events_pct, 0.1, 100),
c.non_events_pct = percent(c.non_events_pct, 0.1, 100))
kable(gains_table)
gains_table <- function(act, pred, increasing = T, nBins = 10){
q <- quantile(pred, probs = seq(0, 1, length.out = nBins + 1))
bins <- cut(pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
df <- data.frame(act, pred, bins)
df %>%
group_by(bins) %>%
summarise(total = n(),
events = sum(bad_flag == 1),
non_events = sum(bad_flag == 0)) %>%
{if(increasing == TRUE){
arrange(., bins)
}else{
arrange(., desc(bins))
}} %>%
mutate(pop_pct = percent(total/sum(total), 0.1, 100),
c.events_pct = cumsum(events) / sum(events),
c.non_events_pct = cumsum(non_events) / sum(non_events),
ks = round(abs(c.events_pct - c.non_events_pct), 2),
cap_rate = percent(cumsum(events)/sum(events), 1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100),
c.events_pct = percent(c.events_pct, 0.1, 100),
c.non_events_pct = percent(c.non_events_pct, 0.1, 100))
}
gains_table <- function(act, pred, increasing = T, nBins = 10){
q <- quantile(pred, probs = seq(0, 1, length.out = nBins + 1))
bins <- cut(pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
df <- data.frame(act, pred, bins)
df %>%
group_by(bins) %>%
summarise(total = n(),
events = sum(act == 1),
non_events = sum(act == 0)) %>%
{if(increasing == TRUE){
arrange(., bins)
}else{
arrange(., desc(bins))
}} %>%
mutate(pop_pct = percent(total/sum(total), 0.1, 100),
c.events_pct = cumsum(events) / sum(events),
c.non_events_pct = cumsum(non_events) / sum(non_events),
ks = round(abs(c.events_pct - c.non_events_pct), 2),
cap_rate = percent(cumsum(events)/sum(events), 1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100),
c.events_pct = percent(c.events_pct, 0.1, 100),
c.non_events_pct = percent(c.non_events_pct, 0.1, 100))
}
# Test the function
gains_table(test$bad_flag, test$pred, F, 15)
# Test the function
gains_table(test$bad_flag, test$pred, F, 10)
gains_table <- function(act, pred, increasing = T, nBins = 10){
q <- quantile(pred, probs = seq(0, 1, length.out = nBins + 1))
bins <- cut(pred, breaks = q, include.lowest = T, right = T, ordered_result = T)
df <- data.frame(act, pred, bins)
df %>%
group_by(bins) %>%
summarise(total = n(),
events = sum(act == 1),
non_events = sum(act == 0)) %>%
mutate(event_rate = percent(events / total, 0.1, 100)) %>%
{if(increasing == TRUE){
arrange(., bins)
}else{
arrange(., desc(bins))
}} %>%
mutate(pop_pct = percent(total/sum(total), 0.1, 100),
c.events_pct = cumsum(events) / sum(events),
c.non_events_pct = cumsum(non_events) / sum(non_events),
ks = round(abs(c.events_pct - c.non_events_pct), 2),
cap_rate = percent(cumsum(events)/sum(events), 1, 100),
c_event_rate = percent(cumsum(events)/cumsum(total), 0.1, 100),
c.events_pct = percent(c.events_pct, 0.1, 100),
c.non_events_pct = percent(c.non_events_pct, 0.1, 100))
}
# Test the function
gains_table(test$bad_flag, test$pred, F, 10)
# Test the function
tab <- gains_table(test$bad_flag, test$pred, T, 10)
kable(tab)
