{"title":"Monotonic Binning Using XGBoost","markdown":{"yaml":{"title":"Monotonic Binning Using XGBoost","date":"2023-01-19","categories":["R","Credit Risk Analytics","XGBoost"],"image":"../images/monotonic.png","execute":{"echo":true,"warning":false,"message":false,"eval":true}},"headingText":"Creating Monotonic Bins for Credit Risk Modeling","containsRefs":false,"markdown":"\n\n\nMonotonic binning is a technique where variable values are grouped into bins such that event rates increase or decrease consistently across these bins. This approach is particularly valuable in credit risk modeling for two key reasons:\n\n1. **Model Stability**: Monotonic relationships add robustness to models, making them less susceptible to overfitting and more reliable when deployed in production\n2. **Interpretability**: Monotonic relationships are easier to explain to stakeholders and regulators, as they ensure consistent and logical relationships between variables and outcomes\n\n## Required Libraries\n\nWe'll use the following R packages for this demonstration:\n\n```{r}\nlibrary(recipes)  # For data preprocessing\nlibrary(dplyr)    # For data manipulation\nlibrary(xgboost)  # For creating monotonic bins\nlibrary(ggplot2)  # For visualization\n```\n\n## Sample Dataset\n\nFor this demonstration, we'll use a sample from the Lending Club dataset, which contains loan information including whether loans defaulted:\n\n```{r}\n# Load sample data from Lending Club dataset\nsample <- read.csv(\"https://bit.ly/42ypcnJ\")\n\n# Check dimensions of the dataset\ndim(sample)\n```\n\n## Creating a Target Variable\n\nFirst, we need to create a binary target variable that indicates whether a loan defaulted (1) or not (0):\n\n```{r}\n# Define loan statuses that represent defaults\ncodes <- c(\"Charged Off\", \"Does not meet the credit policy. Status:Charged Off\")\n\n# Create binary target variable\nmodel_data <- sample %>%\n  mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))\n```\n\n## Data Preparation\n\nNext, we'll preprocess the data using the `recipes` package to:\n1. Select only numeric variables\n2. Impute missing values with median values\n\n```{r}\n# Create a recipe for preprocessing\nrec <- recipe(bad_flag ~ ., data = model_data) %>%\n  step_select(where(is.numeric)) %>%  # Keep only numeric variables\n  step_impute_median(all_predictors())  # Fill missing values with medians\n\n# Apply the preprocessing steps\nrec <- prep(rec, training = model_data)\ntrain <- bake(rec, new_data = model_data)\n```\n\n## Analyzing Directional Trends\n\nBefore creating monotonic bins, it's helpful to visualize the raw relationship between a predictor variable and the target. Let's examine how the number of credit inquiries in the past 6 months relates to default rates:\n\n```{r}\n# Create dataframe with inquiries and default flag\ndata.frame(x = model_data$inq_last_6mths,\n           y = model_data$bad_flag) %>%\n  filter(x <= 5) %>%  # Focus on 0-5 inquiries for clarity\n  group_by(x) %>% \n  summarise(count = n(),  # Count observations in each group\n            events = sum(y)) %>%  # Count defaults in each group\n  mutate(pct = events/count) %>%  # Calculate default rate\n  ggplot(aes(x = factor(x), y = pct)) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"# of inquiries in past 6 months\", \n       y = \"Default rate\",\n       title = \"Default rate vs number of inquiries\")\n```\n\nNotice that while there's a general upward trend (more inquiries correlate with higher default rates), the relationship isn't perfectly monotonic. This is where our binning approach will help.\n\n## Creating Monotonic Bins with XGBoost\n\nNow we'll leverage XGBoost's monotonicity constraints to create bins that have a strictly increasing relationship with default rates. The key parameter is `monotone_constraints = 1`, which forces the model to create splits that maintain a positive relationship with the target:\n\n```{r}\n# Train XGBoost model with monotonicity constraint\nmdl <- xgboost(\n  data = train %>%\n    select(inq_last_6mths) %>%  # Use only the inquiries variable\n    as.matrix(),  \n  label = train[[\"bad_flag\"]],  # Target variable\n  nrounds = 5,  # Number of boosting rounds\n  params = list(\n    booster = \"gbtree\",\n    objective = \"binary:logistic\",\n    monotone_constraints = 1,  # Force positive relationship\n    max_depth = 1  # Simple trees with single splits\n  ),\n  verbose = 0  # Suppress output\n)\n```\n\n## Retrieving Split Points and Creating Bins\n\nAfter training the model, we can extract the split points that XGBoost identified and use them to create our monotonic bins:\n\n```{r}\n# Extract split points from the model\nsplits <- xgb.model.dt.tree(model = mdl)  \n\n# Create bin boundaries including -Inf and Inf for complete coverage\ncuts <- c(-Inf, unique(sort(splits$Split)), Inf)\n\n# Create and visualize the monotonic bins\ndata.frame(target = train$bad_flag,\n           buckets = cut(train$inq_last_6mths, \n                         breaks = cuts, \n                         include.lowest = TRUE, \n                         right = TRUE)) %>% \n  group_by(buckets) %>%\n  summarise(total = n(),  # Count observations in each bin\n            events = sum(target == 1)) %>%  # Count defaults in each bin\n  mutate(pct = events/total) %>%  # Calculate default rate\n  ggplot(aes(x = buckets, y = pct)) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"Bins\", \n       y = \"Default rate\",\n       title = \"Monotonic Bins for Inquiries\")\n```\n\nNotice how the default rates now increase monotonically across the bins, making the relationship clearer and more interpretable compared to the raw data we visualized earlier.\n\n## Creating a Reusable Function\n\nTo make this process more efficient for multiple variables, let's create a reusable function that handles the entire binning workflow:\n\n```{r}\ncreate_bins <- function(var, outcome, max_depth = 10, plot = TRUE){\n  # Determine relationship direction automatically\n  corr <- cor(var, outcome, method = \"spearman\")\n  direction <- ifelse(corr > 0, 1, -1)  # 1 for positive, -1 for negative correlation\n  \n  # Build XGBoost model with appropriate monotonicity constraint\n  mdl <- xgboost(\n    verbose = 0,\n    data = as.matrix(var),\n    label = outcome,\n    nrounds = 100,  # Single round is sufficient for binning\n    params = list(objective = \"binary:logistic\",\n                  monotone_constraints = direction,  # Apply constraint based on correlation\n                  max_depth = max_depth))  # Control tree complexity\n  \n  # Extract and return split points\n  splits <- xgb.model.dt.tree(model = mdl)\n  cuts <- c(-Inf, sort(unique(splits$Split)), Inf)  # Include boundaries for complete coverage\n  \n  # Optionally visualize the bins\n  if(plot) {\n    data.frame(target = outcome,\n               buckets = cut(var, \n                            breaks = cuts, \n                            include.lowest = TRUE, \n                            right = TRUE)) %>% \n      group_by(buckets) %>%\n      summarise(total = n(),\n                events = sum(target == 1)) %>%\n      mutate(pct = events/total) %>%\n      ggplot(aes(x = buckets, y = pct)) + \n      geom_col() + \n      theme_minimal() + \n      labs(x = \"Bins\", \n           y = \"Default rate\",\n           title = \"Monotonic Bins\")\n  }\n  \n  return(cuts)  # Return the bin boundaries\n}\n```\n\n## Example Usage\n\nYou can use this function to create monotonic bins for any numeric variable by passing the variable and outcome columns:\n\n```{r}\n# Example: Create monotonic bins for annual income\nincome_bins <- create_bins(\n  var = train$annual_inc,\n  outcome = train$bad_flag,\n  max_depth = 5\n)\n```\n","srcMarkdownNoYaml":"\n\n# Creating Monotonic Bins for Credit Risk Modeling\n\nMonotonic binning is a technique where variable values are grouped into bins such that event rates increase or decrease consistently across these bins. This approach is particularly valuable in credit risk modeling for two key reasons:\n\n1. **Model Stability**: Monotonic relationships add robustness to models, making them less susceptible to overfitting and more reliable when deployed in production\n2. **Interpretability**: Monotonic relationships are easier to explain to stakeholders and regulators, as they ensure consistent and logical relationships between variables and outcomes\n\n## Required Libraries\n\nWe'll use the following R packages for this demonstration:\n\n```{r}\nlibrary(recipes)  # For data preprocessing\nlibrary(dplyr)    # For data manipulation\nlibrary(xgboost)  # For creating monotonic bins\nlibrary(ggplot2)  # For visualization\n```\n\n## Sample Dataset\n\nFor this demonstration, we'll use a sample from the Lending Club dataset, which contains loan information including whether loans defaulted:\n\n```{r}\n# Load sample data from Lending Club dataset\nsample <- read.csv(\"https://bit.ly/42ypcnJ\")\n\n# Check dimensions of the dataset\ndim(sample)\n```\n\n## Creating a Target Variable\n\nFirst, we need to create a binary target variable that indicates whether a loan defaulted (1) or not (0):\n\n```{r}\n# Define loan statuses that represent defaults\ncodes <- c(\"Charged Off\", \"Does not meet the credit policy. Status:Charged Off\")\n\n# Create binary target variable\nmodel_data <- sample %>%\n  mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))\n```\n\n## Data Preparation\n\nNext, we'll preprocess the data using the `recipes` package to:\n1. Select only numeric variables\n2. Impute missing values with median values\n\n```{r}\n# Create a recipe for preprocessing\nrec <- recipe(bad_flag ~ ., data = model_data) %>%\n  step_select(where(is.numeric)) %>%  # Keep only numeric variables\n  step_impute_median(all_predictors())  # Fill missing values with medians\n\n# Apply the preprocessing steps\nrec <- prep(rec, training = model_data)\ntrain <- bake(rec, new_data = model_data)\n```\n\n## Analyzing Directional Trends\n\nBefore creating monotonic bins, it's helpful to visualize the raw relationship between a predictor variable and the target. Let's examine how the number of credit inquiries in the past 6 months relates to default rates:\n\n```{r}\n# Create dataframe with inquiries and default flag\ndata.frame(x = model_data$inq_last_6mths,\n           y = model_data$bad_flag) %>%\n  filter(x <= 5) %>%  # Focus on 0-5 inquiries for clarity\n  group_by(x) %>% \n  summarise(count = n(),  # Count observations in each group\n            events = sum(y)) %>%  # Count defaults in each group\n  mutate(pct = events/count) %>%  # Calculate default rate\n  ggplot(aes(x = factor(x), y = pct)) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"# of inquiries in past 6 months\", \n       y = \"Default rate\",\n       title = \"Default rate vs number of inquiries\")\n```\n\nNotice that while there's a general upward trend (more inquiries correlate with higher default rates), the relationship isn't perfectly monotonic. This is where our binning approach will help.\n\n## Creating Monotonic Bins with XGBoost\n\nNow we'll leverage XGBoost's monotonicity constraints to create bins that have a strictly increasing relationship with default rates. The key parameter is `monotone_constraints = 1`, which forces the model to create splits that maintain a positive relationship with the target:\n\n```{r}\n# Train XGBoost model with monotonicity constraint\nmdl <- xgboost(\n  data = train %>%\n    select(inq_last_6mths) %>%  # Use only the inquiries variable\n    as.matrix(),  \n  label = train[[\"bad_flag\"]],  # Target variable\n  nrounds = 5,  # Number of boosting rounds\n  params = list(\n    booster = \"gbtree\",\n    objective = \"binary:logistic\",\n    monotone_constraints = 1,  # Force positive relationship\n    max_depth = 1  # Simple trees with single splits\n  ),\n  verbose = 0  # Suppress output\n)\n```\n\n## Retrieving Split Points and Creating Bins\n\nAfter training the model, we can extract the split points that XGBoost identified and use them to create our monotonic bins:\n\n```{r}\n# Extract split points from the model\nsplits <- xgb.model.dt.tree(model = mdl)  \n\n# Create bin boundaries including -Inf and Inf for complete coverage\ncuts <- c(-Inf, unique(sort(splits$Split)), Inf)\n\n# Create and visualize the monotonic bins\ndata.frame(target = train$bad_flag,\n           buckets = cut(train$inq_last_6mths, \n                         breaks = cuts, \n                         include.lowest = TRUE, \n                         right = TRUE)) %>% \n  group_by(buckets) %>%\n  summarise(total = n(),  # Count observations in each bin\n            events = sum(target == 1)) %>%  # Count defaults in each bin\n  mutate(pct = events/total) %>%  # Calculate default rate\n  ggplot(aes(x = buckets, y = pct)) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"Bins\", \n       y = \"Default rate\",\n       title = \"Monotonic Bins for Inquiries\")\n```\n\nNotice how the default rates now increase monotonically across the bins, making the relationship clearer and more interpretable compared to the raw data we visualized earlier.\n\n## Creating a Reusable Function\n\nTo make this process more efficient for multiple variables, let's create a reusable function that handles the entire binning workflow:\n\n```{r}\ncreate_bins <- function(var, outcome, max_depth = 10, plot = TRUE){\n  # Determine relationship direction automatically\n  corr <- cor(var, outcome, method = \"spearman\")\n  direction <- ifelse(corr > 0, 1, -1)  # 1 for positive, -1 for negative correlation\n  \n  # Build XGBoost model with appropriate monotonicity constraint\n  mdl <- xgboost(\n    verbose = 0,\n    data = as.matrix(var),\n    label = outcome,\n    nrounds = 100,  # Single round is sufficient for binning\n    params = list(objective = \"binary:logistic\",\n                  monotone_constraints = direction,  # Apply constraint based on correlation\n                  max_depth = max_depth))  # Control tree complexity\n  \n  # Extract and return split points\n  splits <- xgb.model.dt.tree(model = mdl)\n  cuts <- c(-Inf, sort(unique(splits$Split)), Inf)  # Include boundaries for complete coverage\n  \n  # Optionally visualize the bins\n  if(plot) {\n    data.frame(target = outcome,\n               buckets = cut(var, \n                            breaks = cuts, \n                            include.lowest = TRUE, \n                            right = TRUE)) %>% \n      group_by(buckets) %>%\n      summarise(total = n(),\n                events = sum(target == 1)) %>%\n      mutate(pct = events/total) %>%\n      ggplot(aes(x = buckets, y = pct)) + \n      geom_col() + \n      theme_minimal() + \n      labs(x = \"Bins\", \n           y = \"Default rate\",\n           title = \"Monotonic Bins\")\n  }\n  \n  return(cuts)  # Return the bin boundaries\n}\n```\n\n## Example Usage\n\nYou can use this function to create monotonic bins for any numeric variable by passing the variable and outcome columns:\n\n```{r}\n# Example: Create monotonic bins for annual income\nincome_bins <- create_bins(\n  var = train$annual_inc,\n  outcome = train$bad_flag,\n  max_depth = 5\n)\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"zenburn","toc":true,"css":["../styles.css"],"output-file":"monotonic-binning-using-xgboost.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","editor":"source","theme":"sketchy","code-copy":true,"title":"Monotonic Binning Using XGBoost","date":"2023-01-19","categories":["R","Credit Risk Analytics","XGBoost"],"image":"../images/monotonic.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}