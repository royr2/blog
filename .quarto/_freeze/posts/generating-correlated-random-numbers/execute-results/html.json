{
  "hash": "b94b4d282595c136407734df2040497f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Generating Correlated Random Numbers in R from Scratch\"\ndate: \"2024-03-19\"\ncategories: [R, Statistics, Simulation]\nimage: \"../images/correlated.png\"\nexecute:\n  echo: true\n  warning: false\n  message: false\n  eval: true\n---\n\n\n\nNeed random data with specific correlation patterns for your simulations? This post shows you how to generate correlated random numbers in R using a simple matrix approach â€“ perfect for testing algorithms or creating realistic synthetic datasets.\n\n## The Cholesky Method in Four Steps\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Define your target correlation matrix\ncor_mat <- matrix(c(1, 0.3, \n                   0.3, 1), nrow = 2, byrow = TRUE)\n\n# 2. Apply Cholesky decomposition\nchol_mat <- chol(cor_mat)\n\n# 3. Generate uncorrelated random numbers\nold_random <- matrix(rnorm(2000), ncol = 2)\n\n# 4. Transform to create correlation\nnew_random <- old_random %*% chol_mat\n\n# Verify the correlation\ncor(new_random)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]      [,2]\n[1,] 1.0000000 0.3206961\n[2,] 0.3206961 1.0000000\n```\n\n\n:::\n:::\n\n\n\nThat's it! The `new_random` matrix now contains values with approximately your target correlation structure. This technique uses Cholesky decomposition to create a transformation matrix that induces the desired correlation when applied to uncorrelated data.\n\n## Watch Out for These Pitfalls\n\n### 1. Start with Truly Random Data\n\nYour input data must be uncorrelated for this method to work correctly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What happens with already correlated input?\nsimulate_correlation <- function(input_correlation, target = 0.3) {\n  results <- replicate(1000, {\n    # Create input with specified correlation\n    x <- rnorm(1000)\n    y <- input_correlation * x + rnorm(1000, sd = sqrt(1 - input_correlation^2))\n    \n    # Apply our method\n    old_random <- cbind(x, y)\n    chol_mat <- chol(matrix(c(1, target, target, 1), ncol = 2))\n    new_random <- old_random %*% chol_mat\n    \n    # Return resulting correlation\n    cor(new_random)[1,2]\n  })\n  return(results)\n}\n\n# Compare results with different input correlations\npar(mfrow = c(1, 2))\nhist(simulate_correlation(0.8), main = \"Starting with Correlated Data\",\n     xlim = c(0, 1), col = \"salmon\")\nhist(simulate_correlation(0.001), main = \"Starting with Random Data\",\n     xlim = c(0, 1), col = \"lightblue\")\n```\n\n::: {.cell-output-display}\n![](generating-correlated-random-numbers_files/figure-html/correlation-comparison-1.png){width=672}\n:::\n:::\n\n\n\nWhen your input data already has correlation patterns, the Cholesky method can't properly override them to create your target correlation.\n\n### 2. Use the Same Distribution for All Variables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Different distributions cause problems\nset.seed(123)\nx1 <- rchisq(1000, df = 3)  # Chi-squared (skewed)\ny1 <- rnorm(1000)           # Normal (symmetric)\nold_mixed <- cbind(x1, y1)\n\n# Same distribution works better\nx2 <- rchisq(1000, df = 3)\ny2 <- rchisq(1000, df = 3)\nold_same <- cbind(x2, y2)\n\n# Apply the same transformation to both\nchol_mat <- chol(matrix(c(1, 0.7, 0.7, 1), ncol = 2))\nnew_mixed <- old_mixed %*% chol_mat\nnew_same <- old_same %*% chol_mat\n\n# Compare results\ncat(\"Target correlation: 0.7\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTarget correlation: 0.7\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Mixed distributions result:\", round(cor(new_mixed)[1,2], 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMixed distributions result: 0.915 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Same distribution result:\", round(cor(new_same)[1,2], 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSame distribution result: 0.699\n```\n\n\n:::\n:::\n\n\n\nMixing different distributions (like normal and chi-squared) can lead to unexpected correlation patterns after transformation.\n\n### 3. Distribution Properties Can Change\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Original positive-only distribution\nx <- rchisq(1000, df = 3)  # Always positive\ny <- rchisq(1000, df = 3)  # Always positive\nold_random <- cbind(x, y)\n\n# Apply negative correlation\nchol_mat <- chol(matrix(c(1, -0.7, -0.7, 1), ncol = 2))\nnew_random <- old_random %*% chol_mat\n\n# Check what happened\ncat(\"Original data range:\", round(range(old_random), 2), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOriginal data range: 0.02 19.93 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Transformed data range:\", round(range(new_random), 2), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTransformed data range: -12.81 19.93 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Negative values in result:\", sum(new_random < 0), \"out of\", length(new_random))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNegative values in result: 488 out of 2000\n```\n\n\n:::\n:::\n\n\n\nThe Cholesky transformation can fundamentally change your data's properties - like introducing negative values into a previously positive-only distribution.\n\n## The Easy Way: Using mvtnorm\n\nFor most real applications, the `mvtnorm` package offers a simpler solution:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the package\nlibrary(mvtnorm)\n\n# Define means and covariance matrix\nmeans <- c(10, 20)  # Mean for each variable\nsigma <- matrix(c(4, 2,   # Covariance matrix\n                  2, 3), ncol = 2)\n\n# See the implied correlation\ncov2cor(sigma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]      [,2]\n[1,] 1.0000000 0.5773503\n[2,] 0.5773503 1.0000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Generate correlated normal data in one step\nx <- rmvnorm(n = 1000, mean = means, sigma = sigma)\n\n# Verify the result\nround(cor(x), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1]  [,2]\n[1,] 1.000 0.613\n[2,] 0.613 1.000\n```\n\n\n:::\n:::\n\n\n\n## When to Use Each Method\n\n**Use the Cholesky method when:**\n- You need to understand the mathematical principles\n- You're working with non-normal distributions\n- You need to create custom correlation structures\n\n**Use mvtnorm when:**\n- You need multivariate normal data quickly\n- You want precise control over means and variances\n- You're working with many variables",
    "supporting": [
      "generating-correlated-random-numbers_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}