{
  "hash": "15985fe64e80ff3e749b85620781432c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Building a Particle Swarm Optimizer from Scratch in R\"\ndate: \"2024-07-22\"\ncategories: [R, Optimization, Visualization]\nimage: \"../images/pso_anim.gif\"\nexecute:\n  echo: true\n  warning: false\n  message: false\n  eval: true\n---\n\n\n\nNature-inspired algorithms can solve complex optimization problems with surprising efficiency. This post shows you how to build a Particle Swarm Optimizer (PSO) from scratch in R – mimicking how birds flock or fish school to efficiently search for food.\n\n## Required Libraries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required packages\nlibrary(dplyr)     # For data manipulation\nlibrary(ggplot2)   # For visualization\nlibrary(gganimate) # For animations\nlibrary(metR)      # For geom_arrow\n```\n:::\n\n\n\n## The Challenge: A Complex Optimization Surface\n\nWe'll test our optimizer on Ackley's function – a challenging benchmark with many local minima that can trap optimization algorithms:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_func <- function(x, y){\n  # Modified Ackley function with global minimum at (1,1)\n  -20 * exp(-0.2 * sqrt(0.5 *((x-1)^2 + (y-1)^2))) - \n    exp(0.5*(cos(2*pi*x) + cos(2*pi*y))) + exp(1) + 20\n}\n\n# Create a visualization grid\nx <- seq(-5, 5, length.out = 50)\ny <- seq(-5, 5, length.out = 50)\ngrid <- expand.grid(x, y, stringsAsFactors = FALSE)\ngrid$z <- obj_func(grid[,1], grid[,2])\n\n# Create a contour plot\ncontour_plot <- ggplot(grid, aes(x = Var1, y = Var2)) +\n  geom_contour_filled(aes(z = z), color = \"black\", alpha = 0.5) +\n  scale_fill_brewer(palette = \"Spectral\") + \n  theme_minimal() + \n  labs(x = \"x\", y = \"y\", title = \"Ackley's Function\")\n\ncontour_plot\n```\n\n::: {.cell-output-display}\n![](building-particle-swarm-optimizer_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n## How PSO Works\n\nPSO mimics how birds find food by combining individual memory with social information:\n\n1. Scatter random \"particles\" across the search space\n2. Each particle remembers its personal best position\n3. The swarm shares information about the global best position\n4. Particles adjust their movement based on both personal and swarm knowledge\n\nThe movement equation balances three forces:\n\n$$v_{new} = w \\cdot v_{current} + c_1 \\cdot r_1 \\cdot (p_{best} - p_{current}) + c_2 \\cdot r_2 \\cdot (g_{best} - p_{current})$$\n\nWhere:\n- `w`: Inertia weight (momentum)\n- `c1`: Personal influence (memory)\n- `c2`: Social influence (cooperation)\n- `r1,r2`: Random values adding exploration\n\n## Building PSO Step by Step\n\n### Step 1: Initialize the Swarm\n\nFirst, we create a random swarm of particles and place them across our search space:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set parameters\nn_particles <- 20\nw <- 0.5     # Inertia weight\nc1 <- 0.05   # Personal learning rate\nc2 <- 0.1    # Social learning rate\n\n# Create random particle positions\nx_range <- seq(-5, 5, length.out = 20)\ny_range <- seq(-5, 5, length.out = 20)\nX <- data.frame(\n  x = sample(x_range, n_particles, replace = FALSE),\n  y = sample(y_range, n_particles, replace = FALSE)\n)\n\n# Visualize initial positions\ncontour_plot + \n  geom_point(data = X, aes(x, y), color = \"red\", size = 2.5) + \n  labs(title = \"Initial Particle Positions\")\n```\n\n::: {.cell-output-display}\n![](building-particle-swarm-optimizer_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n### Step 2: Track Best Positions and Initialize Velocities\n\nNext, we track each particle's personal best position and the swarm's global best position:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initialize random velocities\ndX <- matrix(runif(n_particles * 2), ncol = 2) * w\n\n# Set initial personal best positions\npbest <- X\npbest_obj <- obj_func(X[,1], X[,2])\n\n# Find global best position\ngbest <- pbest[which.min(pbest_obj),]\ngbest_obj <- min(pbest_obj)\n\n# Visualize with arrows showing pull toward global best\nX_dir <- X %>% \n  mutate(g_x = gbest[1,1], \n         g_y = gbest[1,2], \n         angle = atan((g_y - y)/(g_x - x))*180/pi,\n         angle = ifelse(g_x < x, 180 + angle, angle))\n\ncontour_plot + \n  geom_point(data = X, aes(x, y), color = \"red\", size = 2.5) + \n  geom_segment(data = X_dir, \n               aes(x = x, y = y, \n                   xend = x + 0.5*cos(angle*pi/180), \n                   yend = y + 0.5*sin(angle*pi/180)), \n               arrow = arrow(length = unit(0.1, \"cm\")), \n               color = \"blue\") + \n  labs(title = \"Forces Acting on Particles\")\n```\n\n::: {.cell-output-display}\n![](building-particle-swarm-optimizer_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n### Step 3: Update Particle Positions\n\nNow we update each particle's position based on its velocity and the forces acting on it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate new velocities using PSO equation\ndX <- w * dX + \n      c1*runif(1)*(pbest - X) + \n      c2*runif(1)*(as.matrix(gbest) - X)\n\n# Update positions\nX <- X + dX\n\n# Evaluate function at new positions\nobj <- obj_func(X[,1], X[,2])\n\n# Update personal best positions if improved\nidx <- which(obj <= pbest_obj)\npbest[idx,] <- X[idx,]\npbest_obj[idx] <- obj[idx]\n\n# Update global best position\nidx <- which.min(pbest_obj)\ngbest <- pbest[idx,]\ngbest_obj <- min(pbest_obj)\n\n# Visualize updated positions\nX_dir <- X %>% \n  mutate(g_x = gbest[1,1], \n         g_y = gbest[1,2], \n         angle = atan((g_y - y)/(g_x - x))*180/pi,\n         angle = ifelse(g_x < x, 180 + angle, angle))\n\ncontour_plot + \n  geom_point(data = X, aes(x, y), color = \"red\", size = 2.5) + \n  geom_segment(data = X_dir, \n               aes(x = x, y = y, \n                   xend = x + 0.5*cos(angle*pi/180), \n                   yend = y + 0.5*sin(angle*pi/180)), \n               arrow = arrow(length = unit(0.1, \"cm\")), \n               color = \"blue\") + \n  labs(title = \"Particles After First Update\")\n```\n\n::: {.cell-output-display}\n![](building-particle-swarm-optimizer_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n## Complete PSO Implementation\n\nNow let's package everything into a reusable function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npso_optim <- function(obj_func,      # Function to minimize\n                      c1 = 0.05,      # Personal learning rate\n                      c2 = 0.05,      # Social learning rate\n                      w = 0.8,        # Inertia weight\n                      n_particles = 20,  # Swarm size\n                      init_fact = 0.1,   # Initial velocity factor\n                      n_iter = 50        # Maximum iterations\n){\n  # Define search domain\n  x <- seq(-5, 5, length.out = 100)\n  y <- seq(-5, 5, length.out = 100)\n  \n  # Initialize particles\n  X <- cbind(sample(x, n_particles, replace = FALSE),\n             sample(y, n_particles, replace = FALSE))\n  dX <- matrix(runif(n_particles * 2) * init_fact, ncol = 2)\n  \n  # Initialize best positions\n  pbest <- X\n  pbest_obj <- obj_func(x = X[,1], y = X[,2])\n  gbest <- pbest[which.min(pbest_obj),]\n  gbest_obj <- min(pbest_obj)\n  \n  # Store positions for visualization\n  loc_df <- data.frame(X, iter = 0)\n  iter <- 1\n  \n  # Main optimization loop\n  while(iter < n_iter){\n    # Update velocities\n    dX <- w * dX + \n          c1*runif(1)*(pbest - X) + \n          c2*runif(1)*t(gbest - t(X))\n    \n    # Update positions\n    X <- X + dX\n    \n    # Evaluate and update best positions\n    obj <- obj_func(x = X[,1], y = X[,2])\n    idx <- which(obj <= pbest_obj)\n    pbest[idx,] <- X[idx,]\n    pbest_obj[idx] <- obj[idx]\n    \n    # Update global best\n    idx <- which.min(pbest_obj)\n    gbest <- pbest[idx,]\n    gbest_obj <- min(pbest_obj)\n    \n    # Store for visualization\n    iter <- iter + 1\n    loc_df <- rbind(loc_df, data.frame(X, iter = iter))\n  }\n  \n  return(list(X = loc_df, \n              obj = gbest_obj, \n              obj_loc = paste0(gbest, collapse = \",\")))\n}\n```\n:::\n\n\n\nLet's test our optimizer on the Ackley function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run the PSO algorithm\nout <- pso_optim(obj_func,\n                 c1 = 0.01,    # Low personal influence\n                 c2 = 0.05,    # Moderate social influence\n                 w = 0.5,      # Medium inertia\n                 n_particles = 50,\n                 init_fact = 0.1,\n                 n_iter = 200)\n\n# Check the result (global minimum should be at (1,1))\nout$obj_loc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1.0000238436846,0.999984789266684\"\n```\n\n\n:::\n:::\n\n\n\n## Visualizing the Swarm in Action\n\nThe real beauty of PSO is watching the particles converge on the solution:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create animation of the optimization process\nggplot(out$X) +\n  geom_contour(data = grid, aes(x = Var1, y = Var2, z = z), color = \"black\") +\n  geom_point(aes(X1, X2)) +\n  labs(x = \"X\", y = \"Y\") +\n  transition_time(iter) +\n  ease_aes(\"linear\")\n```\n:::\n\n\n\n![](../images/pso_anim.gif)\n\n## Fine-Tuning Your Swarm\n\nThe PSO algorithm's behavior can be dramatically altered by adjusting three key parameters:\n\n1. **Inertia Weight (w)**\n   - High values (>0.8): Particles maintain momentum and explore widely\n   - Low values (<0.4): Particles slow down and focus on refining solutions\n\n2. **Personal Learning Rate (c1)**\n   - High values: Particles favor their own discoveries\n   - Low values: Particles ignore their history\n\n3. **Social Learning Rate (c2)**\n   - High values: Particles rush toward the global best\n   - Low values: Particles explore independently\n\nCommon parameter combinations:\n- Exploration focus: High w (0.9), balanced c1/c2 (0.5/0.5)\n- Exploitation focus: Low w (0.4), higher c2 than c1 (0.1/0.7)\n\n## Enhancing Your PSO Implementation\n\nFor real-world applications, consider these improvements:\n\n- Add boundary constraints to keep particles within valid regions\n- Implement adaptive parameters that change during optimization\n- Add convergence-based stopping criteria\n- Extend to higher dimensions for more complex problems\n\nThe R package [`pso`](https://cran.r-project.org/web/packages/pso/index.html) offers a production-ready implementation! \n",
    "supporting": [
      "building-particle-swarm-optimizer_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}