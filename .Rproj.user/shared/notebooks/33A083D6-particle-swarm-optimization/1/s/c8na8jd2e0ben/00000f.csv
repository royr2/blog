"0","# Use only the first two assets for this example"
"0","# Calculate their average returns and covariance matrix"
"0","mean_returns_small <- apply(returns_df[,1:2], 2, mean)"
"0","cov_mat_small <- cov(returns_df[,1:2])"
"0",""
"0","# Define a custom PSO optimizer function to track the optimization process"
"0","pso_optim <- function(obj_func,"
"0","                      c1 = 0.05,      # Cognitive parameter (personal best influence)"
"0","                      c2 = 0.05,      # Social parameter (global best influence)"
"0","                      w = 0.8,        # Inertia weight (controls momentum)"
"0","                      init_fact = 0.1, # Initial velocity factor"
"0","                      n_particles = 20, # Number of particles in the swarm"
"0","                      n_dim = 2,       # Dimensionality (number of assets)"
"0","                      n_iter = 50,     # Maximum iterations"
"0","                      upper = 1,       # Upper bound for weights"
"0","                      lower = 0,       # Lower bound for weights (no short selling)"
"0","                      n_avg = 10,      # Number of iterations for averaging"
"0","                      ...){"
"0","  "
"0","  # Initialize particle positions randomly within bounds"
"0","  X <- matrix(runif(n_particles * n_dim), nrow = n_particles)"
"0","  X <- X * (upper - lower) + lower  # Scale to fit within bounds"
"0","  "
"0","  # Initialize particle velocities (movement speeds)"
"0","  dX <- matrix(runif(n_particles * n_dim) * init_fact, ncol = n_dim)"
"0","  dX <- dX * (upper - lower) + lower"
"0","  "
"0","  # Initialize personal best positions and objective values"
"0","  pbest <- X  # Each particle's best position so far"
"0","  pbest_obj <- apply(X, 1, obj_func, ...)  # Objective value at personal best"
"0","  "
"0","  # Initialize global best position and objective value"
"0","  gbest <- pbest[which.min(pbest_obj),]  # Best position across all particles"
"0","  gbest_obj <- min(pbest_obj)  # Best objective value found"
"0","  "
"0","  # Store initial positions for visualization"
"0","  loc_df <- data.frame(X, iter = 0, obj = pbest_obj)"
"0","  iter <- 1"
"0","  "
"0","  # Main PSO loop"
"0","  while(iter < n_iter){"
"0","    "
"0","    # Update velocities using PSO formula:"
"0","    # New velocity = inertia + cognitive component + social component"
"0","    dX <- w * dX +                         # Inertia (continue in same direction)"
"0","          c1*runif(1)*(pbest - X) +        # Pull toward personal best"
"0","          c2*runif(1)*t(gbest - t(X))      # Pull toward global best"
"0","    "
"0","    # Update positions based on velocities"
"0","    X <- X + dX"
"0","    "
"0","    # Evaluate objective function at new positions"
"0","    obj <- apply(X, 1, obj_func, ...)"
"0","    "
"0","    # Update personal bests if new positions are better"
"0","    idx <- which(obj <= pbest_obj)"
"0","    pbest[idx,] <- X[idx,]"
"0","    pbest_obj[idx] <- obj[idx]"
"0","    "
"0","    # Update global best if a better solution is found"
"0","    idx <- which.min(pbest_obj)"
"0","    gbest <- pbest[idx,]"
"0","    gbest_obj <- min(pbest_obj)"
"0","    "
"0","    # Store current state for visualization"
"0","    iter <- iter + 1"
"0","    loc_df <- rbind(loc_df, data.frame(X, iter = iter, obj = pbest_obj))"
"0","  }"
"0","  "
"0","  # Return optimization results"
"0","  lst <- list(X = loc_df,          # All particle positions throughout optimization"
"0","              obj = gbest_obj,     # Best objective value found"
"0","              obj_loc = gbest)     # Weights that achieved the best objective"
"0","  return(lst)"
"0","}"
"0",""
"0","# Run the optimization for our two-asset portfolio"
"0","out <- pso_optim(obj_func,"
"0","                 ret_vec = mean_returns_small,  # Expected returns"
"0","                 cov_mat = cov_mat_small,       # Covariance matrix"
"0","                 lambda1 = 10, risk_av = 100,    # Constraint and risk parameters"
"0","                 n_particles = 100,              # Use 100 particles for better coverage"
"0","                 n_dim = 2,                      # Two-asset portfolio"
"0","                 n_iter = 200,                   # Run for 200 iterations"
"0","                 upper = 1, lower = 0,           # Bounds for weights"
"0","                 c1 = 0.02, c2 = 0.02,           # Lower influence parameters for stability"
"0","                 w = 0.05, init_fact = 0.01)     # Low inertia for better convergence"
"0",""
"0","# Verify that the weights sum to approximately 1 (full investment constraint)"
"0","sum(out$obj_loc)"
"1","[1]"
"1"," 0.990193"
"1","
"
